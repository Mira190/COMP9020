#下周flexible week，终于可以喘口气来复习一下了，决定从Week5的内容往前倒着复习，希望可以坚持吧。文转码基础弱，都是非常基础的知识总结。

1. A binary relation  R⊆ SxT
    Fun 对所有s，至多1个t 让(s,t)属于R
    Tot 对所有s，至少1个t ...
    Inj 对所有t，至多1个s ...
    Sur 对所有t，至少1个s ...
    Bij Inj and sur

2. 函数与集合的关系
    若给定集合S和T，则函数f是从集合S到集合T的映射，表示为f: S → T，其中对于每个s ∈ S，都有唯一的t ∈ T与之对应，记作f(s) = t。
    函数集合：记作TS，表示所有从集合S到集合T的函数的集合。

3.符号定义：
    域：Dom(f)，表示函数f的输入的集合，即所有可能作为参数的值的集合。
    值域：Codom(f)，表示函数f的所有可能输出的集合。
    像：f(S)，表示函数f对于集合S中所有元素的输出集合。
    象集：Im(f)，表示函数f的实际输出的集合。
    恒等函数：对于集合S，恒等函数IdS(x) = x，对于任意x ∈ S。
    域：Dom(IdS) = S，因为它可以接受集合S中的任何元素作为输入。
    值域：Codom(IdS) = S，因为它的输出与输入集合相同。
    像：f(S) = S，因为对于任何s ∈ S，f(s) = s。
    象集：Im(IdS) = S，因为恒等函数的输出与输入完全相同

4.非满射函数：考虑一个函数f：{a,...,e}∗ → {a,...,e}∗，其中f(w) → awe。这个函数不是满射的。
    为什么不是满射的呢？因为值域（Codom(f)）只包含单个字符串"awe"，而输入集合为{a,...,e}∗，即包含了除"awe"之外的其他字符串。因此，函数f无法覆盖到输入集合的所有元素，因此不是满射。


5.对于有限集合S和函数f：S → S，以下性质等价：
    满射：函数f是满射，即每个元素都有至少一个对应元素。
    单射：函数f是单射，即每个元素都有唯一的对应元素。
    结论： 在有限集合S的情况下，满射和单射是等价的性质。

6.函数的复合
    如果有两个函数f：S → T和g：T → U，那么它们的复合函数，记作g ◦ f，是一个由以下形式给出的函数：(g ◦ f)(x) = g(f(x))。换句话说，g ◦ f = f;g。
    Fact：复合是结合的：即h ◦ (g ◦ f) = (h ◦ g) ◦ f。单位函数的作用：对于函数g：S → T，有g ◦ IdS = g和IdT ◦ g = g。

7.函数的迭代
    如果一个函数将一个集合映射到自身，即Dom(f) = Codom(f)，则可以将该函数与自身进行复合，即进行迭代操作，记作f ◦ f，f ◦ f ◦ f，等等，也写作f²，f³，等等。

8.逆函数
    如果f是一个函数，则其逆函数记作f⁻¹。需要注意的是，f⁻¹只存在于f是双射的情况下。
    ！逆函数f⁻¹始终存在。
    逆函数的作用：逆函数f⁻¹是将函数f的操作“撤销”的过程。如果f：S → T，并且f⁻¹存在，则有以下关系：
    f⁻¹ ◦ f = IdS
    f ◦ f⁻¹ = IdT
    反之，如果f：S → T和g：T → S，且满足g ◦ f = IdS和f ◦ g = IdT，则逆函数f⁻¹存在且等于g。

9.基本矩阵运算
    转置:矩阵的转置AT是将矩阵的行与列交换得到的新矩阵。如果原矩阵是mxn的，则转置矩阵是„ nxm 的。转置后的矩阵中，原矩阵的第i行第j列的元素变成了转置矩阵的第j行第i列的元素。
    矩阵和:两个同型矩阵A和B的A+B是将对应位置上的元素相加得到的新矩阵
    标量乘积:标量c与矩阵A的乘积cA是将矩阵中的每个元素都乘以标量c得到的新矩阵。
    矩阵乘积:两个矩阵A和B的乘积AB是根据特定规则计算得到的新矩阵。具体而言，矩阵A的行与矩阵B的列对应元素相乘后相加得到新矩阵的元素。

10.比较函数特别是从自然数集N到实数集R的函数有下面几种方式
    相等性:如果对于所有n，函数f(n)和 g(n)相等，则称两个函数相等。
    几乎所有比较:如果对于除了有限个n外的所有n，都有 f(n)< g(n)，则称函数 f(n)几乎处处小于等于 g(n)。
    逐点比较:如果对于所有 n，都有 f(n)< g(n)，则称函数 f(n)小于等于 g(n)。
    渐近增长:表示当n 趋向于正无穷时，函数f(n)和 g(n)的比值的极限

11.渐近上界:
    如果存在常数c> 0和no∈ N，对于所有n ≥ no，都有 g(n)< c·f(n)，则称函数 g(n)是 f(n)的渐近上界。用 O(f(n))表示所有渐近上界的类别。通常用g(n)= O(f(n))表示 g(n)是 f(n)的渐近上界。
    渐近增长的性质:若 f(n)∈ O(g(n))，则 g(n)是 f(n)的渐近下界。
    若 f(n)∈ O(g(n))且g(n)∈ O(h(n)),则f(n)∈ O(h(n))。若f(n)∈ 0(g(n))且j(n)∈ O(k(n))， 
    f (n) ∈ O(h(n))
    f (n) +j(n) ∈ O(g(n)+k(n))
    f (n) · j(n) ∈ O(g(n) · k(n))

12.大O&大omega&大Theta
    大O表示法:如果函数g(n)是函数 f(n)的渐近上界，则称 g(n)∈ O(f(n))。大o表示法用于描述一个函数的渐近增长速度的上限。例如，f(n)= O(g(n))意味着g(n)是f(n)的渐近上界。2
    大omega表示法:如果函数g(n)是函数 f(n)的渐近下界，则称g(n)∈ Ω(f(n))。大Omega 表示法用于描述一个函数的渐近增长速度的下限。
    大Theta表示法:如果函数 g(n)既是函数 f(n)的渐近上界又是渐近下界，则称 g(n)€Θ(f(n))。大 Theta 表示法用于描述一个函数的渐近增长速度的精确相等性。
    g ∈Θ(f) ⇐⇒ f ∈Θ(g)  Θ(f (n)) ⊆ O(f(n))
    Θ(f (n)) ⊆ Ω(f(n)),Θ(f (n)) = O(f(n)) ∩ Ω(f(n))
13 相关的观察
    当我们考虑不同指数函数和对数函数时，我们发现它们的增长速度具有明显的差异。
    例如，当n变大时，n^k的增长速度会迅速超过任何对数函数，即使对数函数的底数不同。
    换句话说，指数函数的增长速度会远远超过对数函数。对数函数的底数不会影响其增长速度。无论我们使用哪种基数，例如 1og2n 或log10n，它们的增长速度都是相同的。
    这意味着不同对数函数的增长行为是等价的。同样，不同底数的指数函数也会有不同的增长速度。较大底数的指数函数会增长得更快。例如，当n变大时，2^n的增长速度会超过 3^n，
    而 3^n又会超过 4^n。这种情况说明了指数函数的增长速度与其底数的大小有关。类似地，当我们比较不同次数的多项式函数时，我们也会观察到类似的现象。
    较高次数的多项式函数在n趋近无穷时增长得更快，而较低次数的多项式函数增长速度较慢。
14 渐近分析
    渐近分析是关于成本随着输入增加而扩展的。标准（默认）方法：
    考虑成本函数的渐近增长
    考虑最坏情况下的输入（最高成本）
    考虑运行时间成本：基本操作的数量
    一个计算的“步骤”；需要恒定数量的计算周期。
    计算操作时计数直到一个常数因子，O(1)，而不是确切的数字。

    一般来说，运行时间只是对执行时间的近似：
    关于基本操作的简化假设
    大 O 中的隐藏常数
    大 O 只关注当 n 变大时的性能极限
    最坏情况输入假设和大 O 结合起来简化了分析：
    可能会导致次优的界限，可能需要进行更好的分析以获得最佳界限：
    更细粒度的上界分析
    
    分析特定情况以找到匹配的下界（大 Ω）
    大 Ω 是最坏情况的下界分析；不是“最佳情况”分析。
15.递归例子
    gcd(Fk,Fk−1) ∈ Ω(log(Fk + Fk−1))
    1.5k ≤ Fk ≤ 2k, so k ∈ Θ(logFk)
16. 递归定义
    基础部分 (B)：通常指定一些初始项，也许只有第一项；
    递归过程 (R)：后续项作为先前项的函数表达式来规定。
    递归公式 (R) 有时也称为递推公式，特别是在处理序列时。

17. 链表结构的抽象视图
    我们可以抽象地将链表结构看作是：
    基础部分 (B)：一个空列表，或者
    递归过程 (R)：一个有序对 (数据, 列表)

18. 递归定义的正确性陷阱
    ？如果递推公式正确，则任何后续项的计算都可以简化为基础部分中给定的初始值。
    例如：函数 g(n) 的递归定义为 g(n) = g(g(n−1)−1)+1，g(0) = 2。这个定义是不完整的，递归可能无法终止。修复定义的方法包括添加规范以确定 g(1) = 2。

19. 主定理
    主定理涵盖了许多实际中出现的递归关系（例如分治算法）。
    假设 T(n) = a·T(n/b) + f(n)，其中 f(n) ∈ Θ(n^c(logn)^k)。
    令 d = logb(a)。那么：
    情况 1：如果 c < d，则 T(n) = Θ(n^d)。
    情况 2：如果 c = d，则 T(n) = Θ(n^c(logn)^k+1)。
    情况 3：如果 c > d，则 T(n) = Θ(f(n))。
    a、b、c、k 必须是常数（不依赖于 n）。
    只有一个递归项。
    递归项的形式是 T(n/b)，而不是 T(n−b)。
    解决方案仅为渐近界限。
    主定理适用于以 T(n) = T(n/b) 定义的递归，而不适用于以 T(n−1) 定义的递归。
    但以下是主定理的一个推论：
    假设 T(n) = a·T(n−1)+bn^k，则：
    如果 a=1，则 T(n) = O(n^k+1)。
    如果 a > 1，则 T(n) = O(a^n)
